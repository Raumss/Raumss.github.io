<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git & GitHub 基础]]></title>
    <url>%2Funcategorized%2FGit-and-GitHub.html</url>
    <content type="text"><![CDATA[记录Git 和GitHub 的基础知识和常用操作 Git 分布式版本管理工具 背景与普通的文件存储系统相比：与SVN 相比： Git 结构工作区 -&gt; 暂存区 -&gt; 本地库 Git 代码托管中心是远程库，Git 客户端本地还有一个库。 代码托管中心： 局域网环境： 自己搭建GitLab 服务器 外网环境： GitHub 码云 Git 的操作：团队内部协作 项目开始，研发负责人（TL）在本地创建一个新项目的本地库A，简称为LA，要将LA 放到远程托管中心托管，就需要在代码托管中心也创建一个库，成为RA。 push 操作：将本地库代码推送到远程代码托管中心； TL 将LA 的代码推送到RA； 其他成员要push 代码需要先加入团队，获取提交代码（push）的权限； clone 操作：复制一份RA 的内容到本地，在本地创建一个RA 的库，并做好一系列的初始化操作； pull 操作：将RA的修改（update）拉取到本地； 团队外成员协作 项目A临时需要一个团队外的成员OM 开发一个功能。 fork 操作：OM在t1时间节点对LA 做了一份复制内容到自己的代码托管中心，简称为LA_t1_fork，然后M就可以在LA_t1_fork 上进行开发； pull request：OM 想让项目创建者TL 将自己的写的功能纳入到LA 中，就需要提出pull request （拉取请求）； merge 操作：TL接收到pull request 之后，需要对OM 的代码进行审核，审核通过之后，将其修改的内容merge （合并）到LA。 Git 仓库初始化123456789101112131415$ cd WorkDir/Git$ mkdir WeChat # 创建项目命令$ cd WeChat$ git init # 将当前目录初始化为本地仓库目录Initialized empty Git repository in WorkDir/Git/WeChat/.git $ ll .git/total 24-rw-r--r-- 1 russ staff 23 Sep 29 16:51 HEAD-rw-r--r-- 1 russ staff 137 Sep 29 16:51 config-rw-r--r-- 1 russ staff 73 Sep 29 16:51 descriptiondrwxr-xr-x 13 russ staff 416 Sep 29 16:51 hooksdrwxr-xr-x 3 russ staff 96 Sep 29 16:51 infodrwxr-xr-x 4 russ staff 128 Sep 29 16:51 objectsdrwxr-xr-x 4 russ staff 128 Sep 29 16:51 refs 设置签名（signature）： 签名的结构：用户名 + email 地址，这个是用来区分项目内不同成员的。 签名中的用户名和代码托管中心（例如GitHub）用户名没有任何关系。 签名分类： 仓库/项目级别：在项目中设置的signature，只在本项目中生效； 123$ git config user.name russ$ git config user.email xxx@xxx.com# 信息保存在仓库目录下.git/config 文件中 系统级别：git 客户端所在的系统中生效的用户签名； 123$ git config --global user.name russ$ git config --global user.email xxx@xxx.com# 信息保存在~/.gitconfig 文件中 如果一个signature 在项目和系统级都有设置，则git 优先使用项目级别signature GitHub]]></content>
      <tags>
        <tag>CS</tag>
        <tag>Tools</tag>
        <tag>Unfinished</tag>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins-Base]]></title>
    <url>%2Funcategorized%2FJenkins-Base.html</url>
    <content type="text"><![CDATA[主要记录Jenkins的安装、配置、使用内容 Jenkins 的安装Jenkins 的安装有三种： Docker 安装 安装包安装 war 文件 硬件要求安装包安装Jenkins 在CentOS 7 环境下进行安装 去Jenkins 下载页面下载Jenkins 最新版的安装包，对于RHEL/Fedora/CentOS 下载rpm 格式安装包即可，安装包是noarch 类型，也就是任何硬件平台下的RHEL/Fedora/CentOS 都可以使用这个rpm 包安装。 1$ rpm -i jenkins-2.138.1-1.1.noarch.rpm Jenkins 的使用Jenkins 的管理Jenkins 系统管理]]></content>
      <tags>
        <tag>Tools</tag>
        <tag>Unfinished</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install-Shadowsocks-on-CentOS]]></title>
    <url>%2Funcategorized%2FInstall-Shadowsocks-on-CentOS.html</url>
    <content type="text"><![CDATA[本文记录在CentOS 上安装配置使用Shadowsocks硬件设备有嵌入式设备Raspberry Pi 和桌面笔记本 x86 CPU Raspberry Pi (CentOS 7.4) 安装Shadowsocks 参考网站，需要使用pip 工具 因为当前系统没有pip，安装一下，参考网站，下载脚本get-pip.py 在Pi 上执行该脚本python get-pip.py，安装pip 安装ShadowSocks： 1$ pip install shadowsocks 参考网站，配置Shadowsocks 客户端要用到的配置文件 添加一个Shadowsocks的service，让其开机自动启动： 123456789$ touch /etc/systemd/system/shadowsocks.service$ vim /etc/systemd/system/shadowsocks.service[Unit]Description=Shadowsocks[Service]TimeoutStartSec=0ExecStart=/usr/bin/sslocal -c /etc/shadowsocks/shadowsocks.json[Install]WantedBy=multi-user.target 启动Shadowsocks 客户端服务： 123456789101112131415$ systemctl enable shadowsocks$ systemctl start shadowsocks$ systemctl status shadowsocks● shadowsocks.service - ShadowsocksLoaded: loaded (/etc/systemd/system/shadowsocks.service; disabled; vendor preset: disabled)Active: failed (Result: exit-code) since Wed 2018-09-19 19:27:04 UTC; 3s agoProcess: 3273 ExecStart=/bin/sslocal -c /etc/shadowsocks/shadowsocks.json (code=exited, status=1/FAILURE)......# 报错了，直接使用客户端程序启动看一下$ sslocal -c /etc/shadowsocks/shadowsocks.json2018-09-19 19:27:32 ERROR method chacha20-ietf-poly1305 not supported# 加密方式不支持# 查看了一下版本，不确定什么问题$ sslocal --versionShadowsocks 2.8.2 搜索“shadowsocks chacha20-ietf-poly1305”，刚开找到了两篇文章，讲的是在RHEL 下安装Shadowsocks 的服务端和客户端。结果，上面提供的源，没有给树莓派架构的用的版本。 只好根据安装包的名字，找到这个工程的源代码shadowsocks-libev 先把一堆要用的依赖文件安装好：12345678910111213# 安装依赖的程序和库$ yum install gcc gettext autoconf libtool automake make pcre-devel asciidoc xmlto c-ares-devel libev-devel libsodium-devel mbedtls-devel -y``` ```bash# 安装库Libsodium$ export LIBSODIUM_VER=1.0.16 # GitHub 页面写的1.0.13版本，但是去到下载页里可以看到没有这个版本了，下载最新的1.0.16版本# 需要翻墙才能下载，可以在笔记本上下载好，使用scp 传到Pi 上$ tar xvf libsodium-1.0.16.tar.gz$ cd libsodium-1.0.16$ ./configure --prefix=/usr &amp;&amp; make$ make install$ ldconfig 12345678910111213141516# 安装 MbedTLS 库$ export MBEDTLS_VER=2.6.0$ wget https://tls.mbed.org/download/mbedtls-$MBEDTLS_VER-gpl.tgz$ tar xvf mbedtls-$MBEDTLS_VER-gpl.tgz$ pushd mbedtls-$MBEDTLS_VER$ make SHARED=1 CFLAGS=-fPIC$ sudo make DESTDIR=/usr install$ popd$ sudo ldconfig``` ```bash $ cd WorkDir/Git/$ git clone https://github.com/shadowsocks/shadowsocks-libev.git$ git submodule update --init --recursive$ cd shadowsocks-libev$ ./autogen.sh &amp;&amp; ./configure &amp;&amp; make x86 平台安装Shadowsocks]]></content>
      <tags>
        <tag>CS</tag>
        <tag>Tools</tag>
        <tag>Unfinished</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jenkins+GitHub+Hexo实现博客自动部署]]></title>
    <url>%2Funcategorized%2FJenkins-GitHub-Hexo-CI-CD.html</url>
    <content type="text"><![CDATA[每次在本地写完博客（Markdown 文件），都要手动执行指令生成静态html文件，然后提交到GitHub 上。通过使用Jenkins，将以上流程自动化，减少重复性劳动，提高效率，减少人工错误。 背景知识Jenkins 是用Java 语言开发的持续集成、部署工具，所以要运行在Java 环境下（JRE）。Jenkins 可以在JRE 中跑，也可以在Docker 中运行。 本文两种方法都尝试一下，先从本地运行Jenkins 开始。 在本地安装运行Jenkins安装JRE 和tomcat在树莓派（CentOS 7.4）上安装，需要找JRE 的ARMv7 版本。JRE8 + Tomcat 8 下载JDK 8 for ARM v7 版本，JDK 中包含了JRE，下载链接，解压出来发现就是 jdk1.8.0_181。123456789101112$ yum provides java...省略...1:java-1.8.0-openjdk-1.8.0.181-3.b13.el7_5.armv7hl : OpenJDK Runtime EnvironmentRepo : updatesMatched from:Provides : java = 1:1.8.0$ yum isntall java.......Installing: java-1.8.0-openjdk armv7hl 1:1.8.0.181-3.b13.el7_5 updates 228 k....... 安装Tomcat 下载tomcat 8:1$ wget -c http://mirrors.shu.edu.cn/apache/tomcat/tomcat-8/v8.5.34/bin/apache-tomcat-8.5.34.tar.gz 还需要安装java-1.8.0-openjdk-devel：1$ yum install java-1.8.0-openjdk-devel 没有安装java-1.8.0-openjdk-devel 的时候，tomcat 可以正常启动，但是访问Jenkins 的时候会显示404. 查看tomcat 的log，会有如下的错误。123456789$ vim /tmp/tomcat/logs/catalina.out......org.apache.cataline.LifecycleException: Failed to start component [StandardEngine[Cataline].StandardHost[localhost].StandardContext[/jenkins]]......Caused by: java.util.zip.ZipException: error in opening zip file at java.util.zip.ZipFile.open(Native Method) ...... at org.apache.cataline.webresources.AbstractSingleArchiveResourceSet.initInternal(AbstractSingleArchiveResourceSet.java:139)...... 安装java-1.8.0-openjdk-devel 之后，可以正常访问Jeninks 页面了。 奇怪的是，在x86 机器上不用安装java-1.8.0-openjdk-devel 也可以正常启动Jenkins tomcat manager 访问控制我的tomcat 是运行在Raspberry Pi上的，从笔记本上访问。但是Manager 页面默认不允许从其他主机上访问。参考Stackoverflow 的回答，指定可以访问Manager 页面的主机IP，我的是192.168.1.11。 配置允许访问的主机IP123456$ touch WorkDir/tomcat/conf/Catalina/localhost/manager.xml$ vim WorkDir/tomcat/conf/Catalina/localhost/manager.xml&lt;Context privileged="true" antiResourceLocking="false" docBase="$&#123;catalina.home&#125;/webapps/manager"&gt; &lt;Valve className="org.apache.catalina.valves.RemoteAddrValve" allow="192.168.1.11" /&gt;&lt;/Context&gt; 添加Manager账号：编辑文件WorkDir/tomcat/conf/tomcat-users.xml，插入以下内容：123456&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;manager-script&quot;/&gt;&lt;role rolename=&quot;manager-jmx&quot;/&gt;&lt;user username=&quot;myName&quot; password=&quot;myPwd&quot; roles=&quot;manager-gui&quot;/&gt;&lt;user username=&quot;myName_script&quot; password=&quot;myPwd&quot; roles=&quot;manager-script&quot;/&gt;&lt;user username=&quot;myName_jmx&quot; password=&quot;myPwd&quot; roles=&quot;manager-jmx&quot;/&gt; 这样访问http://192.168.1.13:8080/manager/html的时候，就可以使用myName和myPwd 进行登录了。 Jenkins 安装配置：访问Jenkins 下载页面，下载Jenkins的war 文件，放到tomcat的webapps 目录下。 启动页面： 解锁界面：此处需要填入密码来开始进行配置，密码可以在tomcat的logs 目录下catalina.out 文件中找到，或者如下图所说的，在/root/.jenkins/secrets/initialAdminPassword 文件中。 插件安装，安装默认推荐的插件 安装插件意外报错了，刚开始以为是因为网站被墙，后来发现是因为树莓派内存空间不够： 后来换成了笔记本，就顺利过了： 确认Jenkins 实例的地址： 创建管理员账号 使用Docker安装运行Jenkins]]></content>
      <tags>
        <tag>CS</tag>
        <tag>Tools</tag>
        <tag>Unfinished</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技能列表【初稿】]]></title>
    <url>%2Funcategorized%2Ftemplate.html</url>
    <content type="text"><![CDATA[本页面为效果测试页面记录作为一个运维该掌握的技能列表初稿，还有很多细节需要丰富 System磁盘管理、分区、RAID、文件系统创建、管理、备份系统用户、群组创建和管理用户、群组的密码系统目录分类和作用定期执行功能应用程序的管理：编译、配置、安装、升级、卸载软件源的管理：源的测速、增加、删除、文件、文本操作 系统调优 分布式文件系统容器 Network概念： OSI 七层模型 TCP/IP 网络模型 IP、Network Mask、IP Class 路由原理 负载均衡 代理服务 CDN Web 服务体系架构 CGI 硬件： Switch Router DNS NIC Cable 工具： LVS HAproxy Nginx varnish squid keepalived Keywords: DatabaseDBMS 概念数据引擎：innodb 等等概念主从复制读写分离连接池shardingMHAbin log大数据HBaseHadoopNoSQLRedisMongoDB 账号管理：创建、删除、授权、密码管理数据的备份、恢复 Monitor监控的资源：CPU、内存、流量、端口日志的查询和排错审计工具监听IP 访问状况 监控工具：Zabbix阿里云 Cloud Monitor企业级日志收集系统：ELK Security账号的权限管理账号的登录管理： 禁用root 远程登录 使用跳板机等等文件的访问权限应用程序的权限ACLSSELinux 加密： 文件加密 通信加密 SSL/TLS GSSAPI 网络防火墙各种服务软件的端口网络攻击的类型和防御手段 DevelopmentPythonShellDockerTomcat、Resin Deployment系统安装、配置 磁盘的划分 文件系统的选择 用户、密码 网络配置 常用的企业服务：DNS、FTP、Http、Mail、时间同步服务器 配置管理： CMS：配置管理系统 salt、ansible、puppet cmdb 信息管理 灰度发布中间件RabbitMQZookeeperNamenode 可持续化集成：Jenkins + GitHub虚拟化：KVMDocker]]></content>
      <tags>
        <tag>CS</tag>
        <tag>Unfinished</tag>
        <tag>Skills</tag>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何2分钟内入睡]]></title>
    <url>%2Funcategorized%2FHow-to-Fall-Asleep-in-120-Seconds.html</url>
    <content type="text"><![CDATA[原文出处：How to Fall Asleep in 120 Seconds原文作者：Sharon Ackman 本文介绍的方法，是U.S Navy Pre-Flight School 的教学内容，即便是喝了咖啡或者在充满引擎噪音的环境中，96%的飞行员也可以2分钟内入睡。 按照下边的步骤，你可以轻松地快速入睡。 充分使用现有的环境条件并非一定要在房间里或者是睡垫上才可以，只要身体能够伸展即可。在U.S Navy Pre-Flight School，飞行员被要求坐在椅子上进行睡眠训练：坐靠在椅子上，双脚平放于地面，双手垂放在大腿之上；当然有睡垫或者房间能躺下进行更好。 面部是放松的关键躺（坐）好之后，接下来的重点就是放松面部，面部是感受的中心。 闭上眼睛，缓慢地深呼吸； 放松面部的43块肌肉，让每块肌肉都松懈下来，不要眯眼或皱眉； 额头肌肉放松； 向外呼气的时候，注意感受你的脸颊、嘴巴、舌头和下巴； 不要睁开眼睛，眼部肌肉不要发力，感觉眼睛深深陷入眼窝； 控制眼窝部分一共有6块肌肉，感受到它们的松弛和无力； 放松了眼睛和面部之后，就可以向身体其它部位发送信号“是时候解开身体了” 放松上半身现在轮到肩膀了，让肩膀放松，下沉，好像要随流水漂离你的身体。感觉你的颈后没有任何的直觉，让肌肉充分的松弛。 深深的吸气，慢慢地呼气，将所有的紧张情绪呼出去。 接下来就是手臂了，从优势手那一侧开始。假设你是右利手，专注在你右臂的二头肌上，感受二头肌的放松和下沉。如果感觉没有放松，那就先让肌肉紧绷，再进行放松。 然后专注在你的右前臂上，让它放松，无力。最后就是手和手指了。让它们垂在你的腿上，好像它们是死的，没有生命的。完成优势手的一侧之后，再进行另一侧手臂的放松。 上半身应该感觉放松和舒适，好像在塌陷一样。至此，所有的步骤就已经完成一半了。 放松腿部让你的右大腿放松，感觉好像是无生命一样。然后就是小腿、脚踝、脚掌。感觉腿部肌肉放松，好像要沉入地面一样。换左腿，重复上面的步骤。 这样你的身体从头到脚都打开，松弛了。 如何让大脑放空最后一步就是让大脑放空10秒钟。也就是说，不要去思考今天发生了哪些不好的事情，或者醒来之后要做什么事，或是什么时候要给你的合作伙伴打电话。思考这些东西，会让你的身体肌肉不由自主的收缩。 你需要保持思维清醒。可以通过在大脑中构想一个静态的图像，假想你正躺在一个舒适的沙发上，在一个漆黑寂静的房间里。在大脑中持续想象这个场景10秒钟。 如果上面的方法不管用，就重复的说“不要思考…… 不要思考…… 不要思考” ，坚持10秒。这个可以清空你的想法，阻止你的思维乱逛。 当你的身体上放松，并且大脑放空10秒后，你差不多就该困了。 学会入和快速入睡，知道如何让自己的身体慢下来，关闭自己的意识，允许自己将自己“重启”。通过有保证的睡眠，让自己休息5分钟。 所有的事情都会变得更轻松。你的思维会更清醒，可以作出更好的决策。你会充满能量。]]></content>
      <tags>
        <tag>Misc</tag>
        <tag>Health</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建自己的博客：Github + Hexo + NexT]]></title>
    <url>%2Ftools%2FCreate_Your_Own_Blog_With_Github_Hexo_NexT.html</url>
    <content type="text"><![CDATA[使用GitHub + NodeJS + Hexo + NexT 主题，搭建一个属于自己的博客网站： GitHub 创建源和配置 安装NodeJS + npm 安装配置Hexo 安装配置Hexo主题NexT 实现自动编译和部署新版本 Hexo 的一些插件探究 准备工作：准备工作： UNIX/Linux：在CentOS 7.4 和Mac NodeJS v8：安装过程状况很多，单独写一篇日志记录 系统安装了Git 拥有GitHub 账号 前2项就不列举了，直接进入Github 的配置内容 GitHub首先你需要有一个GitHub账号，如果没有，访问GitHub网站注册一个。 创建仓库新建一个名为username.github.io 的仓库，username是你的Github 账号名，使用其他的名称无效，这样你将来的网站地址就是https://username.github.io了。 GitHub 的用户名是唯一的，所以每个用户的网站地址也就是唯一的了。 以前创建Repo 之后，需要进入Repo 的设置选项中，设置GitHub Pages，现在GitHub 会自动检测你的Repo的名称，符合条件就会直接启用GitHub Pages 功能。 配置SSH key使用SSH key 替代GitHub 的用户名和密码，连接GitHub 提交代码。12$ cd ~/.ssh # 如果提示没有这个目录说明是第一次使用git$ ssh-keygen -t rsa -C $email_address ssh-keygen 执行过程中会提示输入要生成的key 文件的名称，直接回车使用默认名称id_rsa。 打开GitHub 主页，进入Settings -&gt; SSH and GPG keys -&gt; New SSH key。把 ~/.ssh/id_rsa.pub 文件内容粘贴进去保存。 测试能否使用ssh key 连接：1234$ ssh -T git@github.com # 注意此处使的用就是git@github.com"Are you sure you want to continue connecting (yes/no)?" yes"Hi Raumss! You've successfully authenticated, but GitHub does not provide shell access."# 出现以上提示，说明成功了 测试ssh key 连接GitHub 可能会报错，原因是private/public key 文件权限太过宽松：123456789101112131415161718192021222324$ ssh -T git@github.comThe authenticity of host 'github.com (192.30.253.112)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'github.com,192.30.253.112' (RSA) to the list of known hosts.@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: UNPROTECTED PRIVATE KEY FILE! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@Permissions 0644 for '/Users/russ/.ssh/id_rsa' are too open.It is required that your private key files are NOT accessible by others.This private key will be ignored.Load key "/Users/russ/.ssh/id_rsa": bad permissions# 看一下这两个key 文件的权限$ ll ~/.ssh/-rw-r--r-- 1 russ staff 1675 Sep 27 01:28 id_rsa-rw-r--r-- 1 russ staff 401 Sep 27 01:28 id_rsa.pub# 将两个文件的群组和其他用户的查看权限移除即可$ chmod go-r id_rsa*# 重新进行ssh key 连接测试$ ssh -T git@github.com"Hi Raumss! You've successfully authenticated, but GitHub does not provide shell access." Hexo + NexThexo 网站： 官网：http://hexo.io GitHub：https://github.com/hexojs/hexo Hexo 介绍TODO： Hexo 目录结构TODO： Hexo 安装和使用hexo 的安装和初始化1234$ npm install -g hexo-cli # CentOS 下$ npm install -g hexo # Mac 下$ cd WorkDir/Hexo # 这个目录就是存放博客文件的根目录$ hexo init # 在这个目录下初始化hexo 环境 在hexo 配置文件中配置GitHub 信息：12345$ vim WorkDir/Hexo/_config.ymldeploy: type: git repository: git@github.com:$username/$username.github.io.git branch: master 注意：上面每个字段后边都有一个空格将key 和value 间隔开 生成和运行网站服务：12$ hexo g # 生成静态网页，生成的文件在public 目录下$ hexo s # 启动服务器 接下来就可以通过访问localhost:4000浏览博客了 hexo clean 指令，用来清理hexo 生成的文件。 Hexo 配置导航栏、页眉、页脚配置头像配置、中文支持、时区设置新增图标、新增Menu 菜单Hexo 日志的整理方式，默认使用时间作文路径，然用tags和category分类日志永久链接格式 Hexo 操作新增page、目录、tags 搜索栏本地搜索，依赖的包：12$ cd WorkDir/Hexo$ npm install hexo-generator-searchdb --save NexT 主题NexT 在GitHub 上的源码 安装NexT主题：12$ mkdir WorkDir/Hexo/themes/NexT$ git clone https://github.com/theme-next/hexo-theme-next NexT 以上操作，将NexT 主题安装到Hexo 中了。 修改hexo 配置文件 WorkDir/Hexo/_config.yml，将theme:landscape 修改为theme:NexT Hexo 添加插件安装git 插件，这样可以直接使用hexo 指令提交代码到GitHub 上12$ npm install hexo-deployer-git --save# Mac 下，需要使用sudo hexo-deployer-git 插件会检查_config.yml 配置文件中deploy配置块，当中配置了你的GitHub 账号信息（上面已经配置好了）。浏览量统计SEOgit 插件本地搜索插件 自动发布参考阅读： Hexo折腾记——自动部署篇 Hexo 自动部署到GitHub 使用 Travis CI 自动更新 GitHub Pages 性能优化绑定域名参考阅读： 使用GitHub+hexo 搭建免费个人博客详细教程 Hexo折腾记——性能优化篇 Hexo 安裝教學、心得筆記]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>Tools</tag>
        <tag>Network</tag>
        <tag>Unfinished</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Systems: A Programer's Perspective]]></title>
    <url>%2Funcategorized%2FComputer-Systems-A-Programer-s-Perspective.html</url>
    <content type="text"><![CDATA[内容概要Key words Computer System C language Hardware Software Network Compilation 扩展阅读小土刀：CSAPP 读薄]]></content>
      <tags>
        <tag>Unfinished</tag>
        <tag>Computer System</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础]]></title>
    <url>%2Flanguages%2FPython-Base.html</url>
    <content type="text"><![CDATA[Python 基础内容 数据类型：int, long, float, string, tuple, 语法成分：变量、常量、语法、语义、异常、函数、模块、类、lambada、表达式、语句 逻辑控制：条件判断和循环语句 递归 以上分类存疑，还需要进一步理解语言才行语言类通用的部分会整理到专门的语言相关的日志，本日志只保留Python 特有的一些知识点 关于Think Python 2E 这本书中讲了很多语言学的东西，还需要再单独归纳出来，放到一个单独的笔记当中； 应该还有很多通用的概念，比如变量、数据类型等等，这些东西都是通用的，其实都是可以去掉的。因为以后熟悉了，都用不到了，不论在哪一种编程语言中都会降到这些内容； 语言之间互相通用的一些概念，可以归纳到编程语言设计的范畴，如果以后接触编译器/解释器活着语言学的内容，可以归纳到一起； 对于通用内容或语言学的内容，使用特定的tag ——general 标记出来 梳理脉络：语言学 -&gt; 编译器/解释器 -&gt; 编程语言 -&gt; Python/C/C++ 笔记最终保存的内容应该只是python 自己特有的内容 The Way of the Programblahh Variables, Expressions, StatementsVariables变量名可以是任意长度，可以包含字母和数字、下划线，但是必须以字母开头。通常变量名都用小写字母，如果给一个变量起了一个非法的名字，interpreter 会报语法错误。 Python 3 的关键词：123456False True Noneclass def lambda yield raisefinally and return continue for while try elif if else or pass break exceptdel import assert global nonlocalnot from with in as is Expressions and StatementsAn expression is a combination of values, variables and operators. A value all by itself is considered an expressioin, and so is a variable, so the following are all legal expressions:123456&gt;&gt;&gt; 4242&gt;&gt;&gt; n 17&gt;&gt;&gt; n + 2542 When you type an expression at the prompt, the interpreter evaluates it, which means that it finds the value of the expression. In this example, n has the value 17 and n+25 has the value 42. A statement is a unit of code that has an effect, like creating a variable or displaying a value. 12n = 17 # assignment statement, gives a value to `n`.print(n) # a print statement that displays the value of `n`. When you tpye a statement, the interpreter executes it , which means that it does whatever the statement says. In general, statements don’t have values. String operations字符串一般来说不能进行输血运输，也就是所谓的加减乘除幂运算一类。但是python 中，字符串可以进行+操作，这个操作是将两个字符串连接起来。12345a = 'apple'b = 'banana'print (a + b)结果是：applebanana 也就是说，字符串类型中+运算符并不是数值类型中的+，而是“字符串连接运算符“，将两个字符串首尾相接。string 类型的+操作，没有数字类型的+操作那样，可以交换操作数的位置，也就是不适用“交换律”。 出自之外，*运算符也可以用在字符串类型上，表示重复左侧字符串n次。需要注意的是，*的左侧，必须是str类型，右侧必须是int类型，不能颠倒，也不能换成其他数据类型，float 也是不可以的。 FunctionsFunction calls 函数定义：parameter、argument、return value 函数调用 In the context of programming, function is a named sequence of statements that performs a computation. When you define a funtion, you specify the name and the sequence of statements. Later, you can “call“ the function by name. Python 也提供方法做数据类型转换。int 函数可以讲数据类型转换成integer，但是不会做“四舍五入”，而是直接砍掉小数部分。123456&gt;&gt;&gt; int(3.9)3&gt;&gt;&gt; int(-2.3)-2&gt;&gt;&gt; int('32')32 float 函数将integer 和string 转换成浮点数。str 函数将argument 转成string 类型。 A module is a file that contains a collection of related functions. Before we use the functions in a module, we have to import it with an import statement. import math, this statement creates a module boject named math. If you display the module, you get some information about it:12&gt;&gt;&gt; math &lt;module 'math' from ...... The module object contains the functions and variables defined in the module. To access one of the functions, you have to specify the name of the module and the name of the function, separated by a dot(also known as a period). This format is called dot notation.12345&gt;&gt;&gt; ratio = signal_power /noise_power&gt;&gt;&gt; decibels = 10 * math.log10(ratio)&gt;&gt;&gt; radians = 0.7&gt;&gt;&gt; height = math.sin(radians) CompositionOne of the most useful features of programming languages is their ability to take small building blocks and compose them. For example, the argument of a function can be any kind of expression, including arithmetic operators: x = math.sin(degrees / 360.0 * 2 * math.pi). And even function calls: x = math.exp(math.log(x+1)). 几乎任何可以放一个value的地方都可以替换成表达式，赋值语句=左边必须是variable name，表达式放在左边是语法错误。12&gt;&gt;&gt; minutes = hours * 60 # right&gt;&gt;&gt; hours * 60 = minutes # wrong Function DefinitionA function definition specifies the name of a new function and the sequence of statements that run when the function is called. The name of the function is a variable that refers to a function object. A function object is a value you can assign to a variable or pass as an argument.函数对象也是一个“值”，可以赋值给一个变量或者作为实际变量传递给另一个函数。 123def FUNC_NAME (PARAMETER LIST): STATEMENT 1; STATEMENT 2; def 是python 关键词，表示这是一个函数定义； def 后面跟的是函数名，括号() 中的是形参列表（Parameter list）； 函数名的命名规则和变量名一致： 字母、数字、下划线都可以，但不能以数字开头； 不能使用关键词作为函数名； 避免代码中有变量和函数重名； 函数定义的第一行称为header，必须以（:）结尾 其余部分称为body，body部分必须缩进，python 默认一个缩进是4个空格； python 函数定义时候使用def关键词，不需要指定函数（返回）类型； 没有使用{} 包裹函数体，直接将函数体代码缩进，表示当前语句的归属； 函数定义会像其他语句一样被执行，它的作用是生成一个函数对象（function object）； 函数定义体中的代码只有当函数被调用的时候，才会执行； 调用函数前必须已经创建这个函数（函数定义要在函数调用之前）； Flow of execution要确保函数调用前已经被定义，你必须弄清楚代码的执行顺序，也就是”flow of execution“。 程序执行都是从第一行代码开始，逐条往下执行，函数定义也是这样的，但是函数定义体中的代码之后当函数被调用的时候才会执行。 函数调用会让执行流跳转到被调用函数的定义体中，执行完成之后再返回继续往下执行。 当一个函数调用中用到了其他的函数的时候，程序的执行流程就开始变得麻烦了。 Parameters and Arguments比较两者的不同，在Stack Overflow 看到的答案： Argument is often used in the sense of “actual argument” vs. “formal parameter”. The formal parameter is what’s given in the function declaration/definition/prototype, the actual argument is what’s passed when calling the function, an instance of a formal parameter, if you will.That being said, they’re often used interchangably, or depending on language/community. parameter 通常称为“形式参数”，在函数声明/定义的时候用到；argument通常称为“实际参数”在函数调用的时候用到，将值传递给函数定义中的形式参数。 variables and parameters are local, 它们都有自己的作用域。超过这个作用域之外，它们是不存在的。 如果函数调用的时候发生错误，Python会将执行出错的函数名打印出来，并且打印调用这个函数的函数，以及调用“调用这个函数的函数”的函数，直到返回到“main”函数。 12345678Traceback (innermost last): File &quot;test.py&quot;, line 13, in __main__ cat_twice(line1, line2) File &quot;test.py&quot;, line 5, in cat_twice print_twice(cat) File &quot;test.py&quot;, line 9, in print_twice print(cat)NameError: name &apos;cat&apos; is not defined 上面的一系列输出我们称之为traceback，它会告诉你程序执行时候错误发生在哪里 Fruitful Functions and Void Functions那些有返回值的函数，称为“fruitful functions“；相反，没有返回值的，称为“void functions”。 void function 可能会现实一些信息，或者有其它效果，但是不会有返回值。如果将void function 赋值给一个变量，变量的值就是None，是Python中的一个特殊值。 Why Functions 使用函数的形式，将一组有特定功能的语句组合起来，并给它们一个有意义的名字，这样让代码更容易阅读和除错； 函数可以减少重复代码，让程序更小。如果要修改一个功能，只要修改一个函数即可； 将一个很长的应用程序分割成多个函数，这样可以逐个排查函数，最后将他们组合到一起； 设计良好的函数可以供给多个程序使用。一旦写好一个函数，并且已经验证过，就可以重复使用它； DebuggingDebug 是写代码过程中最考验智慧，最有挑战和有趣的部分。 对一些人来说，“编程”和“debug”是一回事。编程就是不断的debug 直到代码可用的过程。 Conditionals and Recursion这一章主要是讲条件语句和递归。 在此之前先讲两个运算符：// （floor division） 和 %（modulus，取余运算符）。 Floor Division and ModulusFloor division （//） 就是将两个数相除，获得的结果向下取整（往小值取）。1234&gt;&gt;&gt; 3.0//21.0&gt;&gt;&gt; -3.0//2-2.0 # 往小了取 Modulus ,%, 取余运算符，就是两个整数（integers）相除只保留余数部分：12&gt;&gt;&gt; 105 % 6045 取余运算符可以用来检查一个数字是否可以被另一个数字整除； 取余运算符可以用来获取一个数的小数点后的数字，比如 3.14，使用3.14 * 100 % 100，这样就知道小数点右边的数字是34了； Python3 和Python2 在integers除法运算上的差异：1234567# python2 &gt;&gt;&gt; 3/21# python3&gt;&gt;&gt; 3/21.5 Boolean Expressions 布尔表达式 A boolean expression is an expression that is either true or false. The following examples use the operator ==, which compares two operands and produces True if they are equal and Flase otherwise:12345&gt;&gt;&gt; 5 == 5True&gt;&gt;&gt; 5 == 6False True 和 False 是布尔类型的两个值，它们并不是string。除了==运算符，还有其它的：12345x != y # 不等于x &gt; y # 大于x &lt; y # 小于x &gt;= y # 大于等于x &lt;= y # 小于等于 Logical Operators 逻辑运算符 三个逻辑运算符：and，or，not。1n % 2 == 0 or n % 3 == 0 # n 能被2或者3整除都返回true 严格来说，逻辑运算符的操作数都应该是布尔表达式，但是Python 在这方面没有非常严格，非0值都算True:12&gt;&gt;&gt; 42 and TrueTrue Conditional Execution 条件执行使用条件语句，根据不同的程序环境，执行不同的指令。12if x &gt; 0: print ('x is positive') if 关键词后边的布尔表达式x &gt; 0 被称为条件。如果条件满足，则后边的语句可以执行，如果不满足条件，则不会执行任何操作。 if 语句的结构和function definition 的结构类似：一个header 后面跟一段语句（body）。这种语句，称为复合语句（compound statements）。body 中可以包含任意数量的语句，但是有时候，body中没有语句也非常有用（很多时候是作为尚未进行的代码的占位符），这种情况下，可以直接使用pass 语句，不会执行任何操作：123if x &lt; 0: pass # TODO: need to handle negativevalues! Alternative Execution 选择执行if 语句的第二种形式，就是有两种可能的情况，根据不同条件决定执行哪些语句：1234if x % 2 == 0: print ('x is even')else: print ('x is odd') 这些可选的执行语句被称为分支，因为他们是程序执行流程中的不同的分支。 Chained Conditionals有些时候可能会有3个以上可能性的情况，所以我们需要更多的分支，这时候就可以使用chained conditional（链式条件）了。 123456if x &lt; y: print ('x is less than y.')elif x &gt; y: print ('x is greater than y.')else: print ('x and y are equal.') elif 语句的使用数量是没有限制的。else 语句必须是最后一个可选条件，但是并非必须有一个else语句。123456if choice == 'a': draw_a()elif choice == 'b': draw_b()elif choice == 'c': draw_c() ⚠️ 注意： 以上每种情况都会按照先后顺序进行检查，前一个为false 才会检查下一种情况； 如果有一个条件是true，就执行该条件对应的语句； 即使有多个条件为True，但是也只执行第一个为True 的语句。 Nested Conditionals 嵌套条件一个条件可以嵌套进另一个条件中，前边的例子可以换一种写法：1234567if x == y: print ('x and y are equal')else: if x &lt; y: print ('x is less than y') else: print ('x is greater than y') 嵌套的结构不利于代码的阅读，所以尽量避免这种情况。 逻辑运算符通常可以用来简化嵌套语句（nested conditoinals），例如：123if 0 &lt; x: if x &lt; 10: print ('x 是大于0的个位数') 修改成如下代码：12if x &gt; 0 and x &lt; 10: print ('x 是大于0的个位数') Python 还提供了更加精简的模式：12if 0 &lt; x &lt; 10: print ('x 是大于0的个位数') Recursion 递归一个函数可以调用另一个函数，同样的，一个函数也可以调用自己本身。 123456789101112def countdown(n): if n &lt;= 0: print ('Blastoff!') else: print(n) countdown(n-1)&gt;&gt;&gt; countdown(3)321Blastoff! 另一个递归函数例子：123456def print_n(s,n): if n &lt;= 0: return else: print(s) print_n(s,n-1) Infinite Recursion 无穷递归递归函数不在进行递归调用的条件，称为基准条件（base case）。如果递归函数永远达不到基准条件，那么这个函数就会一直自我调用下去，这种情况称为“无穷递归”。 一个简单的例子：12def recurse() recurse() 在大多数编程环境中，一个有无穷递归的程序并不能一直执行下去。Python 在达到最大递归深度（通常是1000层）的时候会显示报错信息：1234567 File &quot;&lt;stdin&gt;&quot;, line 2, in recurse File &quot;&lt;stdin&gt;&quot;, line 2, in recurse . . . File &quot;&lt;stdin&gt;&quot;, line 2, in recurseRuntimeError: maximum recursion depth exceeded 书写递归函数的时候，一定要确认是否能够达到基准条件（base case）使函数递归正常结束。 Keyboard InputPython 提供了input 函数让当前程序暂停，接受用户输入，当用户按下回车键之后，程序恢复执行，input函数会将用户输入内容以string 类型返回。input 函数还可以增加提示信息，提示用户该输入何种信息：12345&gt;&gt;&gt; name = input("What ... is your name?\n")What ... is your name?Arthur, King of the Britons!&gt;&gt;&gt; name 'Arthur, King of the Britons!' Debugging当程序出现语法、运行时错误的时候，错误信息可能非常庞杂。最有用的信息通常是如下两种： 错误的种类 出错的位置 语法错误一般都比较容易查到，但是也会有一些比较有迷惑性。尤其是和空白字符有关的语法错误，因为肉眼分不出空格合Tab 的差别，所以容易被忽略：123456&gt;&gt;&gt; x = 5&gt;&gt;&gt; y = 6 File "&lt;stdin&gt;", line 1 y = 6 ^IndentationError: unexpected indent 上面例子的中，错误出现在y 前边的空格键，但是报错指向的是y，有一些误导。所以，错误信息会指出哪里有错误，但是实际上出错的位置可能是在此之前。运行时错误也是如此。 一个运行时错误的例子：123456import mathsignal_power = 9noise_power = 10ratio = signal_power // noise_powerdecibels = 10 * math.log10(ratio)print(decibels) 执行上边的代码会报错：1234Traceback (most recent call last): File &quot;snr.py&quot;, line 5, in ? decibels = 10 * math.log10(ratio)ValueError: math domain error 报错信息显错误出现在第5行，但实际上这一行代码没有问题。打印出ratio 的值之后你才会发现，原来ratio 的值是0。所以是ratio的值不对，所以在第5行用到ratio的时候报错了，但错误的起因在于第4行使用了floor division。所以，要清楚，python 报错描述的是“爆炸”（出错）的地方，但是引信（错误起因）的位置需要你自己来找了。 安装的各种问题CentOS on Raspberry Pi3直接下载源码包，进行编译安装。 首先安装依赖的程序123456789101112131415161718$ yum group install "Development Tools"$ yum install openssl openssl-devel # 通过ssl 获取pip 和setuptools ，这样才能自动安装上setuptools 和pip$ yum install tix tcl-devel tk-devel # tkinter 的依赖$ cd Python-3.4.9# 安装步骤在README 文件中$ ./configure$ make $ make test$ make install....Collecting setuptoolsCollecting pipInstalling collected packages: setuptools, pipSuccessfully installed pip-9.0.1 setuptools-28.8.0# setuptools 和pip 自动安装了 如果不安装openssl，就无法获取setuptools 和pip。 python 源码包的setup 参考文献： 《Think Python 2E》 MIT OCW 6.0001]]></content>
      <categories>
        <category>Languages</category>
      </categories>
      <tags>
        <tag>Unfinished</tag>
        <tag>Languages</tag>
        <tag>todo</tag>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
